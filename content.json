{"meta":{"title":"Aaron Blog","subtitle":"","description":"","author":"Aaron","url":"https://starbuck.top","root":"/"},"pages":[{"title":"about","date":"2020-03-20T03:02:27.000Z","updated":"2020-03-20T12:03:50.668Z","comments":true,"path":"about/index.html","permalink":"https://starbuck.top/about/index.html","excerpt":"","text":"个人简介 Aaron：一名Java后端开发人员 GitHub：https://github.com/starrysky0616 CSDN：https://i.csdn.net/#/uc/profile Email：d_aaron@163.com"},{"title":"categories","date":"2020-03-20T14:52:19.705Z","updated":"2020-03-20T14:52:19.705Z","comments":true,"path":"categories/index.html","permalink":"https://starbuck.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-20T14:52:51.038Z","updated":"2020-03-20T14:52:51.038Z","comments":true,"path":"tags/index.html","permalink":"https://starbuck.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式—适配器模式","slug":"设计模式—适配器模式","date":"2020-01-25T16:00:00.000Z","updated":"2020-04-26T12:12:08.330Z","comments":true,"path":"2020/01/26/设计模式—适配器模式/","link":"","permalink":"https://starbuck.top/2020/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/","excerpt":"适配器模式是一种结构性设计模式，它能使接口不兼容的对象能够相互合作。适配器通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。适配器不仅可以转换不同格式的数据，其还有助于采用不同接口的对象之间的合作。它的运作方式如下： 适配器实现于其中一个对象兼容的接口 现有对象可以使用该接口安全调用适配器方法 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给对象","text":"适配器模式是一种结构性设计模式，它能使接口不兼容的对象能够相互合作。适配器通过封装对象将复杂的转换过程隐藏于幕后。被封装的对象甚至察觉不到适配器的存在。适配器不仅可以转换不同格式的数据，其还有助于采用不同接口的对象之间的合作。它的运作方式如下： 适配器实现于其中一个对象兼容的接口 现有对象可以使用该接口安全调用适配器方法 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给对象 1.代码实现 生活例子：现在有一个轻薄本想要连接网线来上网，但是没有网线接口，所以我们需要买一根转换器来连接网线让我们上网 创建一个电脑类 123456public class Computer &#123; public void net(NetToTypeC netToTypeC)&#123; //找一个转接头连接上网 netToTypeC.handleRequest(); &#125;&#125; 创建一个被适配的类：网线 12345public class ReticleAdapted &#123; public void request()&#123; System.out.println(\"连上网线上网\"); &#125;&#125; 创建一个转换器接口 1234public interface NetToTypeC &#123; //作用：处理请求 public void handleRequest();&#125; 创建真正的适配器 12345678910111213public class Adapter implements NetToTypeC&#123; private ReticleAdapted reticleAdapted; public Adapter(ReticleAdapted reticleAdapted) &#123; this.reticleAdapted = reticleAdapted; &#125; @Override public void handleRequest() &#123; reticleAdapted.request(); &#125;&#125; 测试 12345678public static void main(String[] args) &#123; //电脑 网线 转换器 Computer computer = new Computer(); ReticleAdapted reticleAdapted = new ReticleAdapted(); Adapter adapter = new Adapter(reticleAdapted); computer.net(adapter); &#125; 2.适配器适用性 当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类 适配器模式允许你创建一个中间层类，其可以作为代码与遗留类，第三方类或提供怪异接口的类之间的转换器 当你希望复用多个由于缺少相同功能而无法被添加到已有子类时，可以使用该模式 你可以扩展每个子类，将缺少的功能添加到新的子类中。但是你必须在所有新子类中重复添加这些代码，这样会使得代码有臃肿 将缺失功能添加到一个适配类中是一种解决方案。然后你可以将缺少功能的对象封装在适配器中，从而动态的获取所需功能。如果要这一点正常运作，目标类必须要有通用的接口，适配器的成员变量应当遵循该通用接口，这种模式与装饰模式非常相似 3.对象适配器优点 一个对象适配器可以把多个不同适配者适配到同一个目标 可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏替换原则，适配者子类也可通过该适配器适配","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"适配器模式","slug":"适配器模式","permalink":"https://starbuck.top/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式—桥接模式","slug":"设计模式—桥接模式","date":"2020-01-24T16:00:00.000Z","updated":"2020-04-25T08:25:00.127Z","comments":true,"path":"2020/01/25/设计模式—桥接模式/","link":"","permalink":"https://starbuck.top/2020/01/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","excerpt":"桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。 层次结构中的第一层（通常称为抽象部分）将包含对第二层（实现部分的引用）。抽象部分能将一些对自己的的调用委派给实现部分对象，所有的实现部分都有一个通用接口，因此他们能在抽象部分内部相互替换 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。","text":"桥接模式是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。 层次结构中的第一层（通常称为抽象部分）将包含对第二层（实现部分的引用）。抽象部分能将一些对自己的的调用委派给实现部分对象，所有的实现部分都有一个通用接口，因此他们能在抽象部分内部相互替换 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。 1.为什么会有桥接模式 问题：​ 假如我有一个电脑类型类，从他扩展出两个子类：Notebook(笔记本)和Desktop(台式机)。我现在希望对这些类层次结构进行扩展其品牌，我打算创建名为Apple(苹果)和HUAWEI(华为)。但是我已经有了两个子类，所以总共需要创建四个类才能覆盖所有组合。例如：苹果笔记本，苹果台式机，华为笔记本，华为台式机。 ​ 这样的话在层次结构中新增一个品牌就会导致代码复杂程度指数增长。例如添加一个Lenovo(联想)的品牌，我就需要增加笔记本和台式机两个子类，这样情况会越来越糟糕。 解决方案：​ 问题的根本原因试图在两个独立的维度品牌和类型上拓展品牌类。桥接模式通过将继承改为组合的方式来解决这个问题。具体讲就是抽取其中一个维度使之成为一个独立的类层次，这样就可以在初始类引用这个新层次的对象，从而使得一个类不必具备所有的状态和行为。 2.代码实现 电脑品牌接口 1234public interface Brand &#123; //品牌名称 void info();&#125; 电脑品牌实现类 123456public class Apple implements Brand &#123; @Override public void info() &#123; System.out.print(\"Apple\"); &#125;&#125; 123456public class HuaWei implements Brand&#123; @Override public void info() &#123; System.out.print(\"HuaWei\"); &#125;&#125; 抽象的电脑类型 1234567891011121314151617181920212223242526272829303132333435363738public abstract class Computer &#123; //组合 protected Brand brand; public Computer(Brand brand)&#123; this.brand=brand; &#125; public void info()&#123; //自带品牌 brand.info(); &#125;&#125;//台式机class Desktop extends Computer&#123; public Desktop(Brand brand) &#123; super(brand); &#125; @Override public void info() &#123; super.info(); System.out.println(\"台式机\"); &#125;&#125;//笔记本class Notebook extends Computer&#123; public Notebook(Brand brand) &#123; super(brand); &#125; @Override public void info() &#123; super.info(); System.out.println(\"笔记本\"); &#125;&#125; 测试 12345678public static void main(String[] args) &#123; //HuaWei台式机 Computer computer=new Desktop(new HuaWei()); computer.info(); //Apple笔记本 Computer computer1=new Notebook(new Apple()); computer1.info(); &#125; 现在我想增加一个品牌只需要写一个继承Brand接口的类就可以实现拥有这个品牌的笔记本和台式机","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"桥接模式","slug":"桥接模式","permalink":"https://starbuck.top/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式—代理模式","slug":"设计模式—代理模式","date":"2020-01-22T16:00:00.000Z","updated":"2020-04-24T02:51:45.091Z","comments":true,"path":"2020/01/23/设计模式—代理模式/","link":"","permalink":"https://starbuck.top/2020/01/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","excerpt":"代理模式是为某个对象提供一个代理对象，并由代理对象控制对原对象的访问，就像我们生活中的中介。 例如我要结婚，但是结婚是一件很麻烦的事情，需要安排很多事情，我并不想去准备这些繁琐的事情，只想和心爱的人结婚，其他的事情我还可以出钱交给婚庆公司去准备，婚庆公司为我们安排一整套流程。婚庆公司就相当于我们的代理角色","text":"代理模式是为某个对象提供一个代理对象，并由代理对象控制对原对象的访问，就像我们生活中的中介。 例如我要结婚，但是结婚是一件很麻烦的事情，需要安排很多事情，我并不想去准备这些繁琐的事情，只想和心爱的人结婚，其他的事情我还可以出钱交给婚庆公司去准备，婚庆公司为我们安排一整套流程。婚庆公司就相当于我们的代理角色 1.静态代理 由程序员创建或特定工具自动生成源代码，再对其进行编译。在程序运行之前，代理类.class文件就已经被创建，代理类和委托类的关系在运行前就确定 创建代理接口 123public interface ProxyInterface &#123; void marry();&#125; 真实角色对象（结婚家庭） 123456public class MarriedFamily implements ProxyInterface &#123; @Override public void marry() &#123; System.out.println(\"我们结婚了\"); &#125;&#125; 代理角色（婚庆公司） 12345678910111213141516public class WeddingCompany implements ProxyInterface&#123; private ProxyInterface proxyInterface; public WeddingCompany (ProxyInterface proxyInterface)&#123; this.proxyInterface=proxyInterface; &#125; @Override public void marry() &#123; System.out.println(\"我们是婚庆公司的\"); System.out.println(\"我们在做结婚前的准备工作\"); System.out.println(\"可以开始结婚了\"); proxyInterface.marry(); System.out.println(\"结婚完毕\"); &#125;&#125; 测试 1234567891011121314public class ProxyTest &#123; public static void main(String[] args) &#123; ProxyInterface proxyInterface=new WeddingCompany(new MarriedFamily()); proxyInterface.marry(); &#125;&#125;/** * =====================================结果================================== * 我们是婚庆公司的 * 我们在做结婚前的准备工作 * 可以开始结婚了 * 我们结婚了 * 结婚完毕 **/ 优点：可以做到在符合开闭原则下对目标对象进行功能扩展 缺点： 代理类和委托类都实现了相同的接口，出现大量代码重复，如果接口增加一个方法，除了实现类要实现这个方法外，其他代理类也要实现此方法 代理对象只服务于一种类型的对象，如果要服务多类型的对象。势必要为每一种对象都进行代理，静态代理在程序规模稍大时就无法胜任了 2.动态代理 动态代理是在运行时，通过反射机制实现动态代理，并且能够代理各种类型的对象。想要实现动态代理需要实现InvocationHandler 接口和Proxy类 创建代理接口 123public interface ProxyInterface &#123; void marry();&#125; 真实角色对象 123456public class MarriedFamily implements ProxyInterface &#123; @Override public void marry() &#123; System.out.println(\"我们结婚了\"); &#125;&#125; 动态创建代理对象的类 123456789101112131415161718192021222324252627282930313233343536public class WeddingCompanyHandler implements InvocationHandler &#123; //被代理的接口 private Object target; public void setTarget(Object target)&#123; this.target = target; &#125; /** * 生成得到代理类,Proxy.newProxyInstance()方法接受三个参数： * ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的 * Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型 * InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法 */ public Object getProxy()&#123; return Proxy.newProxyInstance(target.getClass().getClassLoader() , target.getClass().getInterfaces() ,this); &#125; /** * @Description:处理代理实例，并返回结果 * @Param: [o, method, args] * @return: Object */ @Override public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123; System.out.println(\"我们是婚庆公司的\"); System.out.println(\"我们在做结婚前的准备工作\"); System.out.println(\"可以开始结婚了\"); Object result = method.invoke(target, args); System.out.println(\"结婚完毕\"); return result; &#125;&#125; 测试 1234567891011121314151617181920public class ProxyTest &#123; public static void main(String[] args) &#123; //真实角色 ProxyInterface marriedFamily=new MarriedFamily(); //代理角色 WeddingCompanyHandler weddingCompany = new WeddingCompanyHandler(); //通过调用程序处理角色来处理我们要调用的接口对象 weddingCompany.setTarget(marriedFamily); ProxyInterface proxy = (ProxyInterface) weddingCompany.getProxy(); proxy.marry(); &#125;&#125;/** * =====================================结果================================== * 我们是婚庆公司的 * 我们在做结婚前的准备工作 * 可以开始结婚了 * 我们结婚了 * 结婚完毕 **/ 优点：动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强。 缺点：始终无法摆脱仅支持 interface代理，Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://starbuck.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式—工厂模式","slug":"设计模式—工厂模式","date":"2020-01-21T16:00:00.000Z","updated":"2020-04-24T02:51:57.370Z","comments":true,"path":"2020/01/22/设计模式—工厂模式/","link":"","permalink":"https://starbuck.top/2020/01/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式是java最常用的设计模式之一，属于创建型模式，它提供了一种创建对象最佳方式，我们只需要定义一个创建对象的接口，让其子类决定实例化哪一个工厂类。","text":"工厂模式是java最常用的设计模式之一，属于创建型模式，它提供了一种创建对象最佳方式，我们只需要定义一个创建对象的接口，让其子类决定实例化哪一个工厂类。 1.简单工厂模式 现在我们定义一个汽车工厂类，调用者只需要传一个汽车名字（Benz或Audi）就可以创建出相对应的汽车对象 创建一个汽车的接口 123public interface Car &#123; void getName();&#125; 创建实现接口的实现类 123456public class Benz implements Car&#123; @Override public void getName() &#123; System.out.println(\"奔驰\"); &#125;&#125; 123456public class Audi implements Car&#123; @Override public void getName() &#123; System.out.println(\"奥迪\"); &#125;&#125; 创建一个工厂类，用于生成给定信息的实体类对象 123456789101112public class CarFactory &#123; //根据传入的参数来决定实例化的对象 public static Car getCar(String name)&#123; if (name==\"Benz\")&#123; return new Benz(); &#125;else if (name==\"Audi\")&#123; return new Audi(); &#125;else &#123; return null; &#125; &#125;&#125; 使用该工厂，通过传递所需类型信息来获取实例对象 123456789public static void main(String[] args) &#123; Car audi = CarFactory.getCar(\"Audi\"); Car benz = CarFactory.getCar(\"Benz\"); audi.getName(); benz.getName();&#125;//---------------------------------------输出结果-------------------------------------奥迪奔驰 2.抽象工厂模式 抽象工厂模式是围绕一个超级工厂来创造其他工厂，与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品 为手机创建一个接口 1234public interface PhoneProduct &#123; void star(); void sendSMS();&#125; 创建实现手机接口的实现类 12345678910public class MiPhone implements PhoneProduct&#123; @Override public void star() &#123; System.out.println(\"小米开机\"); &#125; @Override public void sendSMS() &#123; System.out.println(\"小米发短信\"); &#125;&#125; 12345678910public class HUAWEIPhone implements PhoneProduct&#123; @Override public void star() &#123; System.out.println(\"华为开机\"); &#125; @Override public void sendSMS() &#123; System.out.println(\"华为发短信\"); &#125;&#125; 为路由器创建一个接口 1234public interface RouterProduct &#123; void star(); void setting();&#125; 创建实现路由器接口的实现类 12345678910public class MiRouter implements RouterProduct&#123; @Override public void star() &#123; System.out.println(\"小米路由器开机\"); &#125; @Override public void setting() &#123; System.out.println(\"小米路由器设置\"); &#125;&#125; 12345678910public class HUAWEIRouter implements RouterProduct&#123; @Override public void star() &#123; System.out.println(\"华为路由器开机\"); &#125; @Override public void setting() &#123; System.out.println(\"华为路由器设置\"); &#125;&#125; 为手机和路由器创建一个抽象产品工厂接口(ProductFactory) 123456public interface ProductFactory &#123; //生产手机 PhoneProduct phoneProduct(); //生产路由器 RouterProduct routerProduct();&#125; 创建手机和路由器抽象产品工厂实现类 1234567891011public class MiFactory implements ProductFactory&#123; @Override public PhoneProduct phoneProduct() &#123; return new MiPhone(); &#125; @Override public RouterProduct routerProduct() &#123; return new MiRouter(); &#125;&#125; 1234567891011public class HUAWEIFactory implements ProductFactory&#123; @Override public PhoneProduct phoneProduct() &#123; return new HUAWEIPhone(); &#125; @Override public RouterProduct routerProduct() &#123; return new HUAWEIRouter(); &#125;&#125; 使用ProductFactory接口来获取不同的实现类 12345678910111213141516171819202122232425262728293031323334353637public class Client &#123; public static void main(String[] args) &#123; PhoneProduct phoneProduct; RouterProduct routerProduct; System.out.println(\"===========================小米========================\"); ProductFactory miFactory = new MiFactory(); //小米手机 phoneProduct = miFactory.phoneProduct(); phoneProduct.star(); phoneProduct.sendSMS(); //小米路由器 routerProduct = miFactory.routerProduct(); routerProduct.star(); routerProduct.setting(); System.out.println(\"===========================华为========================\"); ProductFactory huaweiFactory = new HUAWEIFactory(); //华为手机 phoneProduct = huaweiFactory.phoneProduct(); phoneProduct.star(); phoneProduct.sendSMS(); //华为路由器 routerProduct = huaweiFactory.routerProduct(); routerProduct.star(); routerProduct.setting(); &#125;&#125;//-------------------------------------------输出结果-----------------------------------------===========================小米========================小米开机小米发短信小米路由器开机小米路由器设置===========================华为========================华为开机华为发短信华为路由器开机华为路由器设置","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://starbuck.top/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"}]},{"title":"设计模式—单例模式","slug":"设计模式—单例模式","date":"2020-01-19T16:00:00.000Z","updated":"2020-04-24T02:51:52.191Z","comments":true,"path":"2020/01/20/设计模式—单例模式/","link":"","permalink":"https://starbuck.top/2020/01/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意 单例类只有一个示例 单例类必须自己创建自己唯一的实例 单例类必须给其他对象提供这一实例","text":"单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 注意 单例类只有一个示例 单例类必须自己创建自己唯一的实例 单例类必须给其他对象提供这一实例 1.饿汉式1234567public class HungrySingle &#123; private HungrySingle()&#123;&#125; private static final HungrySingle HUNGRY_SINGLE=new HungrySingle(); public static HungrySingle getHungrySingle()&#123; return HUNGRY_SINGLE; &#125;&#125; 一开始就将对象加载，但是可能存在浪费空间的问题 2.懒汉式123456789101112public class SlackerSingle &#123; private SlackerSingle() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static SlackerSingle slackerSingle; public static SlackerSingle getSlackerSingle() &#123; if (slackerSingle == null) &#123; slackerSingle = new SlackerSingle(); &#125; return slackerSingle; &#125;&#125; 只有需要用到的时候调用它指定的方法去获取对象，但是这种在多线程并发下并不安全 123456789public static void main(String[] args) &#123; for (int i = 0; i &lt;10 ; i++) &#123; new Thread(()-&gt;&#123; SlackerSingle.getSlackerSingle(); &#125;).start(); &#125; &#125;---------------------------------执行结果------------------------------- Thread-0 或 Thread-0 Thread-1 所以我们需要加锁，让他变为线程安全的 1234567891011121314151617public class SlackerSingle &#123; private SlackerSingle() &#123; System.out.println(Thread.currentThread().getName()); &#125; private static SlackerSingle slackerSingle; //双重检测锁模式的懒汉式单例 DCL懒汉式 public static SlackerSingle getSlackerSingle() &#123; if (slackerSingle==null)&#123; synchronized (SlackerSingle.class)&#123; if (slackerSingle == null) &#123; slackerSingle = new SlackerSingle(); &#125; &#125; &#125; return slackerSingle; &#125;&#125; 但是这样还不是安全的，因为他不是一个原子性操作。不是一个原子性操作会经过三个步骤 分配内存空间 执行构造方法，初始化对象 把这个对象指向这个空间 所以我们需要在声明的变量上加上volatile，这样才是一个完整的双重检测锁加原子性操作 1234567891011121314151617public class SlackerSingle &#123; private SlackerSingle() &#123; System.out.println(Thread.currentThread().getName()); &#125; //加上volatile private static volatile SlackerSingle slackerSingle; public static SlackerSingle getSlackerSingle() &#123; if (slackerSingle==null)&#123; synchronized (SlackerSingle.class)&#123; if (slackerSingle == null) &#123; slackerSingle = new SlackerSingle(); &#125; &#125; &#125; return slackerSingle; &#125; &#125; 3.静态内部类模式12345678910public class HolderSingle &#123; private HolderSingle() &#123;&#125; public static HolderSingle getInstance()&#123; return InnerClass.HOLDER_SINGLE; &#125; public static class InnerClass &#123; public static final HolderSingle HOLDER_SINGLE = new HolderSingle(); &#125;&#125; 4.通过反射去破环单例123456789101112public static void main(String[] args) throws Exception&#123; Constructor&lt;SlackerSingle&gt; singleConstructor = SlackerSingle.class.getDeclaredConstructor(null); singleConstructor.setAccessible(true); SlackerSingle slackerSingle = singleConstructor.newInstance(); SlackerSingle slackerSingle2 = singleConstructor.newInstance(); System.out.println(slackerSingle); System.out.println(slackerSingle2); &#125;---------------------------------执行结果-------------------------------com.aaron.single.SlackerSingle@7f31245acom.aaron.single.SlackerSingle@6d6f6e28 我们可以定义一个变量来解决这个问题 123456789101112131415161718192021222324252627282930313233343536373839public class SlackerSingle &#123; //定义一个变量来防止使用反射来破化单例 private static boolean flag=false; private SlackerSingle() &#123; synchronized (SlackerSingle.class) &#123; if (flag==false)&#123; flag=true; &#125;else &#123; throw new RuntimeException(\"切勿使用反射来破坏\"); &#125; &#125; &#125; private static volatile SlackerSingle slackerSingle; public static SlackerSingle getSlackerSingle() &#123; if (slackerSingle == null) &#123; synchronized (SlackerSingle.class) &#123; if (slackerSingle == null) &#123; slackerSingle = new SlackerSingle(); &#125; &#125; &#125; return slackerSingle; &#125;---------------------------------测试------------------------------- public static void main(String[] args) throws Exception &#123; Constructor&lt;SlackerSingle&gt; singleConstructor = SlackerSingle.class.getDeclaredConstructor(null); singleConstructor.setAccessible(true); SlackerSingle slackerSingle = singleConstructor.newInstance(); SlackerSingle slackerSingle2 = singleConstructor.newInstance(); System.out.println(slackerSingle); System.out.println(slackerSingle2); &#125;&#125;---------------------------------执行结果-------------------------------Exception in thread \"main\" java.lang.reflect.InvocationTargetExceptionCaused by: java.lang.RuntimeException: 切勿使用反射来破坏 但是假设我现在知道了这个值，我可以继续破坏单例 1234567891011121314151617181920public static void main(String[] args) throws Exception &#123; //假设我知道了这个变量，可以更改这个变量来继续破化单例 Field flag = SlackerSingle.class.getDeclaredField(\"flag\"); //设置为true 不进行访问安全检查 flag.setAccessible(true); Constructor&lt;SlackerSingle&gt; singleConstructor = SlackerSingle.class.getDeclaredConstructor(null); singleConstructor.setAccessible(true); SlackerSingle slackerSingle = singleConstructor.newInstance(); //改变这个变量的值 flag.set(slackerSingle,false); SlackerSingle slackerSingle2 = singleConstructor.newInstance(); System.out.println(slackerSingle); System.out.println(slackerSingle2); &#125;---------------------------------执行结果-------------------------------com.aaron.single.SlackerSingle@6d6f6e28com.aaron.single.SlackerSingle@135fbaa4 5.使用枚举建造单例模式123456public enum EnumSingle &#123; INSTANCE; public EnumSingle getInstance()&#123; return INSTANCE; &#125;&#125; 123456789101112@Testpublic void enumSingle() throws Exception &#123; EnumSingle instance = EnumSingle.INSTANCE; Constructor&lt;EnumSingle&gt; enumSingleConstructor = EnumSingle.class.getDeclaredConstructor(null); enumSingleConstructor.setAccessible(true); EnumSingle instance2 = enumSingleConstructor.newInstance(); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode());&#125;---------------------------------执行结果-------------------------------java.lang.NoSuchMethodException: com.aaron.single.EnumSingle.&lt;init&gt;() 报错：没有空参构造方法。但是我们通过查看编译后的源代码发现是有空参构造的。 通过专业的反编译工具编译后发现他没有无参，只有有参构造器，需要一个String类型和int类型的值 接下来我们再次尝试传入他需要的值后的执行结果 12345678910111213@Testpublic void enumSingle() throws Exception &#123; EnumSingle instance = EnumSingle.INSTANCE; //传入一个String和int Constructor&lt;EnumSingle&gt; enumSingleConstructor = EnumSingle.class.getDeclaredConstructor(String.class,int.class); enumSingleConstructor.setAccessible(true); EnumSingle instance2 = enumSingleConstructor.newInstance(); System.out.println(instance.hashCode()); System.out.println(instance2.hashCode());&#125;---------------------------------执行结果-------------------------------java.lang.IllegalArgumentException: Cannot reflectively create enum objects 无法使用反射创建枚举对象，所以反射不能破坏枚举的单例","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"https://starbuck.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringCloud微服务入门","slug":"SpringCloud微服务","date":"2020-01-17T16:00:00.000Z","updated":"2020-04-24T02:54:02.422Z","comments":true,"path":"2020/01/18/SpringCloud微服务/","link":"","permalink":"https://starbuck.top/2020/01/18/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/","excerpt":"一.什么是SpringCloud Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。","text":"一.什么是SpringCloud Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等。Spring Cloud 并不重复造轮子，而是将市面上开发得比较好的模块集成进去，进行封装，从而减少了各模块的开发成本。 二.SpringCloud的基础功能 服务发现：Netflix Eureka 客户端负载均衡：Netflix Ribbon 断路器：Netflix Hystrix 服务网关：Netflix Zuul 声明式服务调用”Feign 分布式配置：Spring Cloud Config 三.SpringCloud引入Eureka Spirng Cloud Eureka使用Netflix Eureka来实现服务注册与发现，由两个组件组成：Eureka服务端(Eureka Service)和Eureka客户端(Eureka Client)。而Eureka Client又分为服务提供者和服务消费者。 在项目中加入Eureka服务中心的依赖 12345&lt;!-- Eureka服务中心 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 写yml配置文件 123456789101112131415161718server: port: 7070spring: application: name: eureka-serviceeureka: client: service-url: #该注册中心指向另一个注册中心 互相注册。可配置多个 使用“,”分割 defaultZone: http://127.0.0.1:7070/eureka #是否检索服务 fetch-registry: false #是否向服务注册中心注册自己 register-with-eureka: false instance: #开启后显示服务器地址 prefer-ip-address: true ip-address: 127.0.0.1 在主启动类上加注解 1234567@SpringBootApplication@EnableEurekaServer //将项目作为SpringCloud中的注册中心public class EurekaMain7070 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaMain7070.class,args); &#125;&#125; 将其他服务注册到Eureka注册中心 12345&lt;!-- Eureka客户中心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; 12345678910111213server: port: 8080spring: application: name: user-serviceeureka: client: #表示向注册中心注册自己 默认为true register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true,单节点无所谓,集群必须设置为true才能配合ribbon使用 负载均衡 fetch-registry: true service-url: defaultZone: http://127.0.0.1:7070/eureka #入驻地址 1234567@SpringBootApplication@EnableEurekaClient //让注册中心能够发现public class UserMain8080 &#123; public static void main(String[] args) &#123; SpringApplication.run(UserMain8080.class,args); &#125;&#125; 3.1 Eureka的治理机制 服务提供者 服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上，同时带上了自身服务的一些元数据信息 服务续约：在注册完服务之后，服务提供者会维护一个心跳用来持续告诉Eureka Server: “我还活着 ” 服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求给Eureka Server, 告诉服务注册中心：“我要下线了 ” 服务消费者 获取服务：当我们启动服务消费者的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单 服务调用：服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，优先访问同处一个Zone中的服务提供方。 服务注册中心 失效剔除：默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）没有续约的服务剔除出去 自我保护：EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的实例注册信息保护起来， 让这些实例不会过期，尽可能保护这些注册信息 四.SpringCloud引入Ribbon Ribbon 是一个基于Http和TCP的客服端负载均衡工具，它是基于Netflix Ribbon实现的。它不像spring cloud服务注册中心、配置中心、API网关那样独立部署，但是它几乎存在于每个spring cloud 微服务中。包括feign提供的声明式服务调用也是基于该Ribbon实现的。ribbon提供很多种负载均衡算法（默认的负载均衡策略是轮询），例如 轮询、随机、最少并发策略等等。甚至包含自定义的负载均衡算法。 在项目中加入Ribbon依赖 12345 &lt;!-- ribbon负载均衡 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 在yml配置文件中配置Ribbon负载均衡策略 123provider-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 在主启动类开启负载均衡 12345@Bean@LoadBalancedpublic RestTemplate getRestTemplate()&#123; return new RestTemplate();&#125; 进行测试 12345678910@RestController@RequestMapping(\"user\")public class UserController &#123; @Resource private UserService userService; @GetMapping(\"getUserById/&#123;id&#125;\") public User getUserById(@PathVariable(\"id\") Integer id)&#123; return userService.getUserById(id); &#125;&#125; 12345678910@Servicepublic class UserServiceImpl implements UserService &#123; @Resource private RestTemplate restTemplate; @Override public User getUserById(Integer id) &#123; String url = \"http://provider-service/user/getUserById/\"; return restTemplate.getForObject(url+id,User.class); &#125;&#125; 多次刷新看到调用的端口在来回切换则成功实现负载均衡 五.SpringCloud引入Hystrix 在高并发的情况下，由于单个服务的延迟，可能导致所有的请求都处于延迟状态，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。Hystrix断路器可以防止一个应用程序多次试图执行一个操作，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝）， 向调用方返回一个错误响应， 而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延 在消费者pom中加入Hystrix的依赖包 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在主启动类加入注解 1@EnableHystrix 测试是否生效 12345678910111213141516171819202122@Override@HystrixCommand(fallbackMethod = \"queryUserByIdFallback\", //失败后的回调函数//每十次请求中失败率达到百分之三十则开启熔断，此时再调用该服务，则直接返回失败，直到十秒后重新检测该触发条件，判断是否把熔断器打开或者继续关闭 commandProperties = &#123; @HystrixProperty(name=\"circuitBreaker.requestVolumeThreshold\" ,value=\"10\"), @HystrixProperty(name=\"circuitBreaker.sleepWindowInMilliseconds\" ,value=\"10000\"), @HystrixProperty(name=\"circuitBreaker.errorThresholdPercentage\" ,value=\"30\") &#125;)public User queryUserById(Integer id) &#123; long begin = System.currentTimeMillis(); User user= restTemplate.getForObject(url+id, User.class); long end = System.currentTimeMillis(); logger.info(\"访问用时&#123;&#125;\",end-begin); return user;&#125;private User queryUserByIdFallback(Integer id)&#123; User user = new User(); user.setId(id); user.setUserCode(\"查询用户信息出现异常\"); return user;&#125; 六.SpringCloud引入Feign Feign是一种声明式、模板化的HTTP客户端。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。 在服务调用者pom加入Feign依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在yml写配置文件 1234567feign: hystrix: enabled: true #开启Feign Hystrix 支持 httpclient: enabled: false #关闭httpclient okhttp: enabled: true #开启okHttp 在主启动类加入注解 1@EnableFeignClients 使用Feign实现远程调用 12345678910/*** value:指定调用哪个服务* fallbackFactory:熔断器的降级提示*/@FeignClient(value = \"provider-service\",fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; //采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！ @GetMapping(\"/user/getUserById/&#123;id&#125;\") User userFeign(@PathVariable(\"id\") Integer id);&#125; 1234567891011121314/** * Feign中使用断路器 * 这里主要是处理异常出错的情况(降级/熔断时服务不可用，fallback就会找到这里来) */@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User userFeign(Integer id) &#123; User user = new User(); user.setId(id); user.setUserCode(\"查询用户信息出现异常\"); return user; &#125;&#125; 1234567891011@RestController@RequestMapping(\"user\")public class UserController &#123; @Resource private UserFeignClient userFeignClient; @GetMapping(\"feign/&#123;id&#125;\") public User userFeign(@PathVariable(\"id\") Integer id)&#123; return userFeignClient.userFeign(id); &#125;&#125; 七.SpringCloud引入Zuul Zuul是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul相当于是设备和Netflix流应用的 Web 网站后端所有请求的前门。Zuul和Eureka进行整合,将Zuul自身注册为Eureka服务治理下的应用,同时从Eureka中获得其他微服务的消息,也即以后的访问微服务都是通过Zuul跳转后获得 Zuul包含了对请求的路由和过滤两个最主要的功能:路由转发：接收一切外界请求，转发到后端的微服务上去。过滤器：在服务网关中可以完成一系列的横切功能，例如权限校验、限流以及监控等，这些都可以通过过滤器完成，路由转发也是通过过滤器实现的 新建项目在pom中加入依赖 12345678910 &lt;!-- Zuul网关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Eureka客户中心 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 编写yml配置文件 1234567891011121314server: port: 10080spring: application: #服务的名称 name: zuul-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:9090/eureka #指定注册中心地址zuul: retryable: true ignored-services: - provider-service #忽略整个服务，对外提供接口 编写主启动类 1234567@SpringBootApplication@EnableZuulProxypublic class ZuulMain10080 &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulMain10080.class); &#125;&#125; 自定义过滤器 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Componentpublic class LoginFilter extends ZuulFilter &#123; /** * 返回字符串，代表过滤器的类型。包含以下4种： * pre：请求在被路由之前执行 * routing：在路由请求时调用 * post：在routing和error过滤器之后调用 * error：处理请求时发生错误调用 */ @Override public String filterType() &#123; return \"pre\"; &#125; //通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 @Override public int filterOrder() &#123; return 0; &#125; //返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 @Override public boolean shouldFilter() &#123; return true; &#125; //过滤器的具体业务逻辑。 @Override public Object run() throws ZuulException &#123; // 登录校验逻辑。 // 1）获取Zuul提供的请求上下文对象 RequestContext ctx = RequestContext.getCurrentContext(); // 2) 从上下文中获取request对象 HttpServletRequest req = ctx.getRequest(); // 3) 从请求中获取token String token = req.getParameter(\"access-token\"); // 4) 判断 if(token == null || \"\".equals(token.trim()))&#123; // 没有token，登录校验失败，拦截 ctx.setSendZuulResponse(false); // 返回401状态码。也可以考虑重定向到登录页。 ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125; // 校验通过，可以考虑把用户信息放入上下文，继续向后执行 return null; &#125;&#125; 八.SpringCloud Config 随着业务的扩展，我们的服务会越来越多，越来越多。每个服务都有自己的配置文件。既然是配置文件，给我们配置的东西，那难免会有些改动的。 Spring Cloud Config项目是一个解决分布式系统的配置管理方案。它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。 简单来说，使用Spring Cloud Config就是将配置文件放到统一的位置管理(比如GitHub)，客户端通过接口去获取这些配置文件。在GitHub上修改了某个配置文件，应用加载的就是修改后的配置文件","categories":[{"name":"SrpingCloud","slug":"SrpingCloud","permalink":"https://starbuck.top/categories/SrpingCloud/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://starbuck.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}]},{"title":"SpringBoot框架—SpringBoot集成Swagger2","slug":"SpringBoot框架—SprongBoot集成swagger2","date":"2020-01-14T16:00:00.000Z","updated":"2020-04-24T02:54:41.653Z","comments":true,"path":"2020/01/15/SpringBoot框架—SprongBoot集成swagger2/","link":"","permalink":"https://starbuck.top/2020/01/15/SpringBoot%E6%A1%86%E6%9E%B6%E2%80%94SprongBoot%E9%9B%86%E6%88%90swagger2/","excerpt":"1.在pom.xml中导入依赖123456789101112&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;","text":"1.在pom.xml中导入依赖123456789101112&lt;!-- swagger2 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 2.编写SwaggerConfig类1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2public class SwaggerConfig &#123; /** * 创建API应用 * apiInfo() 增加API相关信息 * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现， * 本例采用指定扫描的包路径来定义指定要建立API的目录。 * @return: Docket */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.accp.controller\")) .paths(PathSelectors.any()) .build(); &#125; /** * 创建该API的基本信息（这些基本信息会展现在文档页面中） * 访问地址：http://项目实际地址/swagger-ui.html * @return: ApiInfo */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"Spring Boot中使用Swagger2\") .description(\"更多请关注http://www.baidu.com\") .termsOfServiceUrl(\"http://www.baidu.com\") .build(); &#125;&#125; 3.使用Restful风格编写Controller1234567891011121314151617181920212223242526@RestController@RequestMapping(\"login\")public class LoginController &#123; @Autowired private UserService userService; @Autowired private Result result; @ApiOperation(value=\"查询\",notes = \"查询用户列表\") @GetMapping(\"findUser\") public Result findUser() &#123; List&lt;User&gt; user = userService.findUser(); result.setCode(1); result.setMsg(\"success\"); result.setData(user); return result; &#125; @ApiOperation(value=\"删除\",notes = \"删除用户\") @DeleteMapping(\"del/&#123;redisKey&#125;\") public void del(@PathVariable String redisKey) &#123; userService.delCache(redisKey); &#125;&#125; 4.启动项目访问Swagger—ui","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/categories/SpringBoot/"}],"tags":[{"name":"Swagger2","slug":"Swagger2","permalink":"https://starbuck.top/tags/Swagger2/"}]},{"title":"SpringBoot框架—SpringBoot集成TK_MyBatis","slug":"SpringBoot框架—SpringBoot集成TK_MyBatis","date":"2020-01-11T16:00:00.000Z","updated":"2020-04-24T02:54:35.265Z","comments":true,"path":"2020/01/12/SpringBoot框架—SpringBoot集成TK_MyBatis/","link":"","permalink":"https://starbuck.top/2020/01/12/SpringBoot%E6%A1%86%E6%9E%B6%E2%80%94SpringBoot%E9%9B%86%E6%88%90TK_MyBatis/","excerpt":"1.搭建Tk_MyBatis环境 在pom.xml导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.3-beta1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt;","text":"1.搭建Tk_MyBatis环境 在pom.xml导入坐标 12345678910&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.3-beta1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 更改实体类 123456789101112131415161718192021@Data@Table(name = \"smbms_user\")public class User implements Serializable &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY,generator = \"JDBC\") private Integer id; @Column(name = \"userCode\") private String userCode; @Column(name = \"userName\") private String userName; @Column(name = \"userPassword\") private String userPassword; @Column(name = \"birthday\") private Date birthday;&#125; 继承Mapper&lt;&gt;类 1public interface BaseMapper extends Mapper&lt;User&gt;&#123;&#125; 可能需要在application.yml中写的配置 12345mybatis: type-aliases-package: com.accp.pojo mapper-locations: classpath:xml/mapper/*.xml configuration: map-underscore-to-camel-case: true 2.TK_MyBatis中的方法详解 INSERT方法 方法名及返回类型 作用 int insert(Object record) 保存一个实体，null的属性也会保存，不会使用数据库默认值 int insertSelective(Object record) 保存一个实体，null的属性不会保存，会使用数据库默认值 DELETE方法 方法名及返回类型 作用 int delete(Object record) 根据实体属性作为条件进行删除，查询条件使用等号 int deleteByPrimaryKey(Object key) 根据主键字段进行删除，方法参数必须包含完整的主键属性 UPDATE方法 方法名及返回类型 作用 int updateByPrimaryKey(Object record) 根据主键更新实体全部字段，null值会被更新 int updateByPrimaryKeySelective(Object record) 根据主键更新属性不为null的值 SELECT方法 方法名及返回类型 作用 List select(Object record) 根据实体中的属性值进行查询，查询条件使用等号 List selectAll() 查询全部结果，select(null)方法能达到同样的效果 int selectCount(Object record) 根据实体中的属性查询总数，查询条件使用等号 Object selectOne(Object record) 根据实体中的属性进行查询，只能有一个返回值，有多个结果是抛出异常，查询条件使用等号 Object selectByPrimaryKey(Object key) 根据主键字段进行查询，方法参数必须包含完整的主键属性，查询条件使用等号 boolean existsWithPrimaryKey(Object key) 通过主键查询此主键是否存在 Examle条件方法 方法名及返回类型 作用 int deleteByExample(Object example) 根据Example条件删除数据 int updateByExample(Object record, Object example) 根据Example条件更新实体record包含的全部属性，null值会被更新 int updateByExampleSelective(Object record, Object example) 根据Example条件更新实体record包含的不是null的属性值 List selectByExample(Object example) 根据Example条件进行查询 Object selectOneByExample(Object example) 根据Example条件进行查询，若有多条数据则抛出异常 int selectCountByExample(Object example) 根据Example条件进行查询总数 分页的方法 方法名及返回类型 作用 List selectByRowBounds(Object record, RowBounds rowBounds) 根据实体属性和RowBounds进行分页查询 List selectByExampleAndRowBounds(Object example, RowBounds rowBounds) 根据example条件和RowBounds进行分页查询 3.TK_MyBatis中的方法示例123456789101112131415161718192021222324252627282930313233343536373839404142434445@Servicepublic class BillServiceImpl implements BillService &#123; @Resource private BillMapper billMapper; @Override public List&lt;Bill&gt; findBill() &#123; return billMapper.selectAll(); &#125; @Override public Bill findBillById(Integer id) &#123; return billMapper.selectByPrimaryKey(id); &#125; /** * @Description: TK_Mybatis根据条件模糊查询 * @Param: [productName] * @return: List&lt;Bill&gt; * @Author: Mr.Du */ @Override public List&lt;Bill&gt; findBillExample(String productName) &#123; Example example = new Example(Bill.class); example.createCriteria() .andLike(\"productName\",'%'+productName+'%'); return billMapper.selectByExample(example); &#125; /** * @Description: TK_Mybatis根据条件模糊查询 * @Param: [productName,productDesc] * @return: List&lt;Bill&gt; * @Author: Mr.Du */ @Override public List&lt;Bill&gt; selectBillExample(String productName,String productDesc) &#123; Example example = new Example(Bill.class); example.createCriteria() .andEqualTo(\"productName\",productName) .andEqualTo(\"productDesc\",productDesc); return billMapper.selectByExample(example); &#125; &#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/categories/SpringBoot/"}],"tags":[{"name":"TK_MyBatis","slug":"TK-MyBatis","permalink":"https://starbuck.top/tags/TK-MyBatis/"}]},{"title":"SpringBoot框架—初始SpringBoot","slug":"SpringBoot框架—初始SpringBoot","date":"2020-01-09T16:00:00.000Z","updated":"2020-04-24T02:54:29.795Z","comments":true,"path":"2020/01/10/SpringBoot框架—初始SpringBoot/","link":"","permalink":"https://starbuck.top/2020/01/10/SpringBoot%E6%A1%86%E6%9E%B6%E2%80%94%E5%88%9D%E5%A7%8BSpringBoot/","excerpt":"1.搭建SpringBoot 使用idea快速搭建spring boot框架","text":"1.搭建SpringBoot 使用idea快速搭建spring boot框架 ![](https://pic.downk.cc/item/5e76c7549d7d586a54736640.png) 选择需要的依赖 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;!-- p6spy --&gt;&lt;dependency&gt; &lt;groupId&gt;p6spy&lt;/groupId&gt; &lt;artifactId&gt;p6spy&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!-- 热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt;&lt;/dependency&gt; 创建测试代码 主程序类 123456789/** * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloWorldMainApplication.class,args); &#125;&#125; mapper层 12345@Repository@Mapperpublic interface UserMapper &#123; List&lt;User&gt; findUser();&#125; 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.accp.mapper.UserMapper\"&gt; &lt;select id=\"findUser\" resultType=\"User\"&gt; SELECT id,userCode,userName,userPassword,birthday FROM smbms_user &lt;/select&gt;&lt;/mapper&gt; service层 1234567891011@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public List&lt;User&gt; findUser()&#123; return userMapper.findUser(); &#125;&#125; controller层 1234567891011@RestController@RequestMapping(\"user\")public class UserController &#123; @Autowired private UserServiceImpl userService; @GetMapping(\"findUser\") public List&lt;User&gt; findUser() &#123; return userService.findUser(); &#125;&#125; 配置application.yml 123456789101112131415161718192021#设置端口号server: port: 8088spring: #MYSQL连接信息 datasource: driver-class-name: com.p6spy.engine.spy.P6SpyDriver url: jdbc:p6spy:mysql://localhost:3306/smbms?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: root hikari: idle-timeout: 6000 maximum-pool-size: 50 minimum-idle: 10 #时间格式化 jackson: date-format: yyyy-MM-dd#mybatis配置:mybatis: type-aliases-package: com.accp.pojo mapper-locations: classpath:xml/mapper/*.xml 2.SpringBoot中常用的一些注解 @SpringBootApplication 包含三个注解：@Configuration、@EnableAutoConfiguration、@ComponentScan @Mapper：用于标注数据访问组件 即用在 Mapper接口层 它是mybatis的注解，Mapper不需要配置扫描地址 @Repository：用于标注数据访问组件 即用在 Mapper/Dao 接口层 它是spring的注解，需要在Spring中配置扫描地址 @Service：用于标注业务层 @RestController：用于标注控制层组件，包含@Controller和@ResponseBody @MapperScan：通过此注解指定Mapper接口路径 3.SpringBoot权限控制1234567891011121314public class LoginHandlerInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取用户是否登录，如果没有登录则带着提示消息回到登录页面 Object user = request.getSession().getAttribute(\"user\"); if (user==null)&#123; request.setAttribute(\"msg\",\"没有权限请先登录\"); request.getRequestDispatcher(\"login.html\").forward(request,response); return false; &#125;else &#123; return true; &#125; &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/tags/SpringBoot/"}]},{"title":"SSM框架整合","slug":"SSM框架整合","date":"2019-12-20T04:12:57.000Z","updated":"2020-04-24T02:57:16.854Z","comments":true,"path":"2019/12/20/SSM框架整合/","link":"","permalink":"https://starbuck.top/2019/12/20/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/","excerpt":"","text":"ssm框架搭建 在pom.xml导入所需依赖包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.6.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--Spring相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入MySQL驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!--阿里的数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis spring整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对jdbc整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--SpringMVC依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--测试依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--分页依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--@ResponseBody依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--JSON依赖包--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- standard --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 如果不添加此节点mybatis的mapper.xml文件都会被漏掉。 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 配置applicationContext.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=\"com.accp.service\"/&gt; &lt;!--读取jdbc.properties--&gt; &lt;bean id=\"ppc\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置数据库连接池--&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;!-- 配置初始化大小、最大 --&gt; &lt;property name=\"initialSize\" value=\"1\" /&gt; &lt;property name=\"maxActive\" value=\"20\" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"60000\" /&gt; &lt;property name=\"minIdle\" value=\"1\" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; &lt;property name=\"testWhileIdle\" value=\"true\" /&gt; &lt;!-- 这里建议配置为TRUE，防止取到的连接不可用 --&gt; &lt;property name=\"testOnBorrow\" value=\"false\" /&gt; &lt;property name=\"testOnReturn\" value=\"false\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt; &lt;property name=\"maxOpenPreparedStatements\" value=\"20\" /&gt; &lt;/bean&gt; &lt;!--配置数据库连接和mybatis的关联--&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--引用数据源组件--&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;!--配置sql映射文件信息--&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:com/accp/mapper/*.xml\"&gt;&lt;/property&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--局部配置文件和接口关联配置--&gt; &lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"&gt;&lt;/property&gt; &lt;property name=\"basePackage\" value=\"com.accp.mapper\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 配置spring-mvc.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd \"&gt; &lt;!--开启包扫描--&gt; &lt;context:component-scan base-package=\"com.accp.controller\"&gt;&lt;/context:component-scan&gt; &lt;!--开启mvc注解扫描--&gt; &lt;mvc:annotation-driven &gt; &lt;!--中文乱码--&gt; &lt;mvc:message-converters&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"&gt; &lt;!--中文乱码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置监听器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--配置拦截器--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置默认页面--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建controller、mapper、pojo、service测试 1234567891011121314@Controller@RequestMapping(\"user\")public class UserController &#123; @Autowired private UserService userService; @RequestMapping(\"getuserInfos\") @ResponseBody public Map&lt;String, Object&gt; getUserInfos(User user, @RequestParam(defaultValue = \"1\") Integer page, @RequestParam(defaultValue = \"5\") Integer limit)&#123; return userService.findUserList(user, page, limit); &#125;&#125; 123public interface UserMapper &#123; List&lt;User&gt; findUser(@Param(\"userName\") String userName, @Param(\"userRole\") int userRole);&#125; 123456789101112131415161718&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.accp.mapper.UserMapper&quot;&gt; &lt;select id&#x3D;&quot;findUser&quot; resultType&#x3D;&quot;com.accp.pojo.User&quot;&gt; select u.*,r.roleName as userRoleName from smbms_user u,smbms_role r &lt;where&gt; u.userRole &#x3D; r.id &lt;if test&#x3D;&quot;userName !&#x3D; null and userName !&#x3D; &#39;&#39;&quot;&gt; and userName like CONCAT(&#39;%&#39;,#&#123;userName&#125;,&#39;%&#39;) &lt;&#x2F;if&gt; &lt;if test&#x3D;&quot;userRole !&#x3D; null and userRole !&#x3D; &#39;&#39;&quot;&gt; and userRole &#x3D;#&#123;userRole&#125; &lt;&#x2F;if&gt; &lt;&#x2F;where&gt; order by creationDate DESC &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 123456789101112131415161718192021@Datapublic class User &#123; private Integer id; private String userCode; private String userName; private String userPassword; private Integer gender; @JSONField(format = \"yyyy-MM-dd\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday; private String phone; private String address; private Integer userRole; private Integer createdBy; private Date creationDate; private Integer modifyBy; @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date modifyDate; private Integer age; private String userRoleName;&#125; 1234567891011121314151617@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public Map&lt;String, Object&gt; findUserList(User user, Integer pageNum, Integer pageSize) &#123; PageHelper.startPage(pageNum,pageSize); List&lt;User&gt; userList = userMapper.findUser(user.getUserName(),user.getUserRole()); PageInfo&lt;User&gt; pageInfo = new PageInfo(userList); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",0); map.put(\"msg\",\"success\"); map.put(\"count\",pageInfo.getTotal()); map.put(\"data\",pageInfo.getList()); return map; &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/tags/SSM/"}]},{"title":"SpringMVC框架 — SpringMVC拓展","slug":"SpringMVC框架—SpringMVC拓展","date":"2019-12-18T16:00:00.000Z","updated":"2020-04-24T02:54:53.475Z","comments":true,"path":"2019/12/19/SpringMVC框架—SpringMVC拓展/","link":"","permalink":"https://starbuck.top/2019/12/19/SpringMVC%E6%A1%86%E6%9E%B6%E2%80%94SpringMVC%E6%8B%93%E5%B1%95/","excerpt":"1.SpringMvc的Model与ModelAndView Model：用于接收数据传递到显示页面，需要作为参数传递 addAttribute(String name,Object value)：添加键值对属性 addAttribute(Object obj)：将一个对象存到对象中，把该类名首字母小写作为key值 asMap()：将当前model转换为Map mergeAttribute(Map &lt;String,?&gt; hashmap)：和addAttribute相同，但允许有相同的key值 containsAttribute(String name)：判断model中是否包含一个键值对，返回boolean ModelAndView：将控制器处理的结果数据返回到显示页面，作为返回类型使用，也可设置转向地址 setViewName(String path)：设置转向地址 addObject(String name , Object value)：将控制器处理的结果数据返回到显示页面","text":"1.SpringMvc的Model与ModelAndView Model：用于接收数据传递到显示页面，需要作为参数传递 addAttribute(String name,Object value)：添加键值对属性 addAttribute(Object obj)：将一个对象存到对象中，把该类名首字母小写作为key值 asMap()：将当前model转换为Map mergeAttribute(Map &lt;String,?&gt; hashmap)：和addAttribute相同，但允许有相同的key值 containsAttribute(String name)：判断model中是否包含一个键值对，返回boolean ModelAndView：将控制器处理的结果数据返回到显示页面，作为返回类型使用，也可设置转向地址 setViewName(String path)：设置转向地址 addObject(String name , Object value)：将控制器处理的结果数据返回到显示页面 2.JSON数据传递处理 在方法上加@ResponseBody，通过JSON.toJSONString()将数据转换为json格式 解决json数据传递乱码问题：在@RequestMapping里面加 produces = {“application/json;charset=UTF-8”} 解决json数据传递日期问题：在属性上加 @JSONField(format = “yyyy-MM-dd”) 3.SpringMVC文件上传 导入maven坐标 12345&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; springmvc.xml配置CommonsMultipartResolver 1234567&lt;bean id=\"multipartResolver\"class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--上传文件的最大大小，单位为字节 --&gt; &lt;property name=\"maxUploadSize\" value=\"17367648787\"&gt;&lt;/property&gt; &lt;!-- 上传文件的编码 --&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"&gt;&lt;/property&gt;&lt;/bean&gt; 设置前端jsp页面：input的type设置为file，from表单的enctype设置为multipart/form-data Controller层使用MultipartFile对象作为参数，接收前端发送过来的文件，将文件写入本地文件中 12345678910111213141516171819202122@RequestMapping(\"/uploadFile\")public String uploadFile(@RequestParam(\"file\") MultipartFile file, HttpServletRequest req) throws IllegalStateException, IOException &#123; // 判断文件是否为空，空则返回失败页面 if (file.isEmpty()) &#123; return \"失败页面\"; &#125; // 获取文件存储路径（绝对路径） String path = req.getSession().getServletContext().getRealPath(\"/WEB-INF/file\"); // 获取原文件名 String fileName = file.getOriginalFilename(); // 创建文件实例 File filePath = new File(path, fileName); // 如果文件目录不存在，创建目录 if (!filePath.getParentFile().exists()) &#123; filePath.getParentFile().mkdirs(); System.out.println(\"创建目录\" + filePath); &#125; // 写入文件 file.transferTo(filePath); return \"成功页面\";&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://starbuck.top/tags/SpringMVC/"}]},{"title":"SpringMVC框架 —  初始SpringMVC","slug":"SpringMVC框架—初始SpringMVC","date":"2019-12-17T16:00:00.000Z","updated":"2020-04-24T02:54:48.500Z","comments":true,"path":"2019/12/18/SpringMVC框架—初始SpringMVC/","link":"","permalink":"https://starbuck.top/2019/12/18/SpringMVC%E6%A1%86%E6%9E%B6%E2%80%94%E5%88%9D%E5%A7%8BSpringMVC/","excerpt":"","text":"1.创建SpringMVC项目 新建一个maven项目 （为了快速引入jar： archetypeCatalog internal）) 在pom.xml中导入SpringMVC的相关依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; 在resources目录下创建spring-mvc.xml配置文件 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd \"&gt; &lt;!--开启包扫描--&gt; &lt;context:component-scan base-package=\"com.accp.*\"&gt;&lt;/context:component-scan&gt; &lt;!--开启mvc注解扫描--&gt; &lt;mvc:annotation-driven &gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 编写web.xml配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE web-app PUBLIC &quot;-&#x2F;&#x2F;Sun Microsystems, Inc.&#x2F;&#x2F;DTD Web Application 2.3&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;web-app_2_3.dtd&quot; &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;&#x2F;display-name&gt; &lt;!--中文乱码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt; &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; &lt;!-- 配置核心控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;&#x2F;param-value&gt; &lt;&#x2F;init-param&gt; &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt; &lt;&#x2F;servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;&#x2F;servlet-name&gt; &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; &lt;&#x2F;servlet-mapping&gt; &lt;!--配置异常处理页面--&gt; &lt;error-page&gt; &lt;exception-type&gt;java.lang.Exception&lt;&#x2F;exception-type&gt; &lt;location&gt;&#x2F;error&#x2F;error.jsp&lt;&#x2F;location&gt; &lt;&#x2F;error-page&gt;&lt;&#x2F;web-app&gt; 2.SpringMVC常用注解 @Controller：定义了一个控制器类，使用它标记的类就是一个SpringMVC Controller 对象。 @RequestMapping：是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 value： 指定请求的实际地址，指定的地址可以是URI Template 模式 method： 指定请求的method类型， GET、POST、PUT、DELETE等 consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回 params： 指定request中必须包含某些参数值是，才让该方法处理 headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求 @Resource和@Autowired：都是做bean的注入时使用 @requestParam：主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”) @ResponseBody：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。 3.SpringMVC的跳转方式 请求转发：默认的controller的跳转方式为请求转发，相当于return “forward:路径”，默认forward:可以省略 重定向：通过配置 return “redirect:路径”来表示进行重定向","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://starbuck.top/tags/SpringMVC/"}]},{"title":"Spring框架 — Spring与Mybatis整合","slug":"Spring框架—Spring与Mybatis整合","date":"2019-12-16T16:00:00.000Z","updated":"2020-04-24T02:54:23.891Z","comments":true,"path":"2019/12/17/Spring框架—Spring与Mybatis整合/","link":"","permalink":"https://starbuck.top/2019/12/17/Spring%E6%A1%86%E6%9E%B6%E2%80%94Spring%E4%B8%8EMybatis%E6%95%B4%E5%90%88/","excerpt":"1.在pom.xml中导入相关坐标依赖","text":"1.在pom.xml中导入相关坐标依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 &lt;!-- spring版本号 --&gt;&lt;properties&gt; &lt;spring.version&gt;4.3.6.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--Spring相关依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入MySQL驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!--阿里的数据库连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis spring整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring对jdbc整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--引入lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;!-- 配置编译依赖工具 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--解决版本问题，发布项目时避免文件丢失--&gt; &lt;resources&gt; &lt;!--resources文件--&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 是否被过滤,如果被过滤则无法使用 --&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;!--java文件--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 2.编写applicationContext.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--告知spring在创建容器时需要扫描的包，配置所需要的标签不是在beans约束中， 而是一个名称为context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.accp\"&gt;&lt;/context:component-scan&gt; &lt;!--读取jdbc.properties--&gt; &lt;bean id=\"ppc\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\" value=\"classpath:jdbc.properties\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置数据库连接池--&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置数据库连接和mybatis的关联--&gt; &lt;bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--引用数据源组件--&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;!--配置sql映射文件信息--&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:com/accp/mapper/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--局部配置文件和接口关联配置--&gt; &lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"&gt;&lt;/property&gt; &lt;property name=\"basePackage\" value=\"com.accp.mapper\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.建立开发目录结构 建立实体类Bill 1234567@Datapublic class Bill &#123; private int id; private String billCode; private String productName; private String productDesc;&#125; 建立mapper层 1List&lt;Bill&gt; findBill(Bill bill); 123456789101112&lt;select id=\"findBill\" resultType=\"com.accp.pojo.Bill\"&gt; SELECT b.`id`,b.`billCode`,b.`productName`,b.`productDesc` FROM smbms_bill b &lt;where&gt; &lt;if test=\"id!=null and id!=''\"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"productName!=null and productName!=''\"&gt; and productName LIKE CONCAT('%',#&#123;productName&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 建立service层 123456789@Servicepublic class BillServiceImpl implements BillService &#123; @Autowired private BillMapper billMapper; public List&lt;Bill&gt; findBill(Bill bill)&#123; return billMapper.findBill(bill); &#125;&#125; 创建测试类 12345678910ApplicationContext ac= new ClassPathXmlApplicationContext(\"applicationContext.xml\");BillServiceImpl billService = ac.getBean(\"billServiceImpl\", BillServiceImpl.class);Bill bill=new Bill();bill.setId(1);bill.setProductName(\"皂\");List&lt;Bill&gt; billList = billService.findBill(bill);for (Bill bills : billList) &#123; System.out.println(bills);&#125;((ClassPathXmlApplicationContext)ac).close();","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://starbuck.top/tags/Spring/"}]},{"title":"Spring框架 — IOC和AOP使用扩展","slug":"Spring框架—IOC和AOP使用扩展","date":"2019-12-15T16:00:00.000Z","updated":"2020-04-24T02:52:36.368Z","comments":true,"path":"2019/12/16/Spring框架—IOC和AOP使用扩展/","link":"","permalink":"https://starbuck.top/2019/12/16/Spring%E6%A1%86%E6%9E%B6%E2%80%94IOC%E5%92%8CAOP%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95/","excerpt":"1.多种方式实现依赖注入 构造函数注入 12345&lt;bean id=\"accountService\" class=\"com.accp.service.impl.accountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 标签的属性: type:用于指定要注入的数据的数据类型，该数据类型也是构造函数中的某个或某些参数 index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引位置从0开始 name:用于指定给构造函数中指定名称的参数赋值 value:用于提供基本类型和String类型的数据 ref:用于指定其他bean类型的数据。它指的是在spring的IOC核心容器出现过的bean对象","text":"1.多种方式实现依赖注入 构造函数注入 12345&lt;bean id=\"accountService\" class=\"com.accp.service.impl.accountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 标签的属性: type:用于指定要注入的数据的数据类型，该数据类型也是构造函数中的某个或某些参数 index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引位置从0开始 name:用于指定给构造函数中指定名称的参数赋值 value:用于提供基本类型和String类型的数据 ref:用于指定其他bean类型的数据。它指的是在spring的IOC核心容器出现过的bean对象 使用set方法注入 12345&lt;bean id=\"accountService\" class=\"com.accp.service.impl.accountServiceImpl\"&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt;&lt;/bean&gt; 标签的属性: name:用于指定注入时所调用的set方法名称 value:用于提供基本类型和String类型的数据 ref:用于指定其他bean类型的数据。它指的是在spring的IOC核心容器出现过的bean对象 复杂类型注入 12345678910111213141516171819202122232425262728293031323334&lt;bean id=\"accountService\" class=\"com.accp.service.impl.accountServiceImpl\"&gt;&lt;!--注入list--&gt;&lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;王五&lt;/value&gt; &lt;value&gt;赵六&lt;/value&gt; &lt;value&gt;钱七&lt;/value&gt; &lt;/list&gt;&lt;/property&gt;&lt;!--注入set--&gt;&lt;property name=\"set\"&gt; &lt;set&gt; &lt;value&gt;王五&lt;/value&gt; &lt;value&gt;赵六&lt;/value&gt; &lt;value&gt;钱七&lt;/value&gt; &lt;/set&gt;&lt;/property&gt;&lt;!--注入map--&gt;&lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"a\" value=\"王五\"&gt;&lt;/entry&gt; &lt;entry key=\"b\" value=\"赵六\"&gt;&lt;/entry&gt; &lt;entry key=\"c\" value=\"钱七\"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt;&lt;!--注入properties--&gt;&lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"a\"&gt;王五&lt;/prop&gt; &lt;prop key=\"b\"&gt;赵六&lt;/prop&gt; &lt;prop key=\"c\"&gt;钱七&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; 2.使用注解实现IoC配置 在applicationContext.xml中配置创建容器需要扫描的包 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--告知spring在创建容器时需要扫描的包，配置所需要的标签不是在beans约束中， 而是一个名称为context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.accp\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 2.使用注解定义Bean @Component:，value用于指定bean的id，他的默认名称是当前类名，且首字母小写 @Controller:一般用于表现层 @Service:一般用于业务层 @Repository:一般用在持久层 3.使用注解实现Bean组件装配3.1.用于注入数据的 @Autowired:作用：自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功 12@Autowiredprivate accountDao accountDao; @Qualifier(“Str”):作用:在按照类中注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用（和Autowired组合在一起），但是在给方法参数注入时可以使用 123@Autowired@Qualifier(\"accountDao\")private accountDao accountDao; @Resource(name = “Str”)：作用:直接按照bean的id注入，可以独立使用属性:value用于指定bean的id 12@Resource(name = \"accountDao\")private accountDao accountDao; @value:作用:用于注入基本数据类型和string类型数据属性:value用于指定数据的值，它可以使用spring中的SpEl（spring的EL表达式）SpEl写法:${表达式} 12@Value(\"$&#123;jdbc.driver&#125;\")private String driver; 3.2.用于改变作用范围 @Scope:作用:用于指定bean的作用范围 12@Scope(\"singleton\")public class accountServiceImpl&#123;&#125; 3.3.和生命周期相关的 @PostConstruct:用于指定初始化方法 1234@PostConstructpublic void init()&#123; System.out.println(\"初始化\");&#125; @PreDestroy:用于指定销毁方法 1234@PreDestroypublic void destroy()&#123; System.out.println(\"销毁\");&#125; 3.4.spring中的新注解 @Configuration:指定当前类是一个配置类 细节:当配置类作为AnnotationConfigApplicationContext对象创建的参数时该注解可以不写 12@Configurationpublic class SpringConfiguration &#123;&#125; @ComponentScan:通过注解指定spring在创建容器时要扫描的包 使用此注解相当于在xml中配置了:&lt;context:component-scan base-package=”com.accp”/&gt; 123@Configuration@ComponentScan(basePackages = \"com.accp\")public class SpringConfiguration &#123;&#125; @PropertySource:用于指定PropertySource文件的位置属性: value指定文件的名称和路径，classPath指的是当前文件的类路径 1234@Configuration@ComponentScan(basePackages = \"com.accp\")@PropertySource(\"classpath:jdbc.properties\")public class SpringConfiguration &#123;&#125; @Bean:用于把当前方法的返回值作为bean对象存入IOC容器中 属性:name用于指定bean的id，默认值是当前方法的名称 12@Bean(name = \"dataSource\")public DataSource createDataSource() &#123;&#125; @Import(Class):用于导入其他配置类 4.使用注解标注AOP切面 @Aspect ：表示当前类是一个切面类 12@Aspectpublic class Logger &#123;&#125; @Pointcut： 12@Pointcut(\"execution(* com.accp.service.impl.*.*(..))\")private void pt1()&#123;&#125; @Before：前置通知 1234@Before(\"pt1()\")public void prLogger()&#123; System.out.println(\"前置prLogger日志开始工作\");&#125; @AfterReturning：后置通知 1234@AfterReturning(\"pt1()\")public void afterReturnPrLogger()&#123; System.out.println(\"后置afterReturnPrLogger日志开始工作\");&#125; @AfterThrowing：异常通知 1234@AfterThrowing(\"pt1()\")public void afterThrowingPrLogger()&#123; System.out.println(\"异常afterThrowingPrLogger日志开始工作\")&#125; @After：异常通知 1234@After(\"pt1()\")public void afterPrLogger()&#123; System.out.println(\"最终afterPrLogger日志开始工作\");&#125; @Around：环绕通知 1234567891011121314151617@Around(\"pt1()\")public Object aroundLogger(ProceedingJoinPoint pjp)&#123; Object rtValue; try &#123; Object[] args=pjp.getArgs(); System.out.println(\"前置aroundLogger日志开始工作\"); //proceed()方法相当于明确调用切入点方法。 rtValue=pjp.proceed(args); System.out.println(\"后置aroundLogger日志开始工作\"); return rtValue; &#125; catch (Throwable e) &#123; System.out.println(\"异常aroundLogger日志开始工作\"); throw new RuntimeException(e); &#125;finally &#123; System.out.println(\"最终aroundLogger日志开始工作\"); &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://starbuck.top/tags/Spring/"}]},{"title":"Spring框架 — Spring核心概念","slug":"Spring框架—Spring核心概念","date":"2019-12-14T16:00:00.000Z","updated":"2020-04-24T02:54:15.168Z","comments":true,"path":"2019/12/15/Spring框架—Spring核心概念/","link":"","permalink":"https://starbuck.top/2019/12/15/Spring%E6%A1%86%E6%9E%B6%E2%80%94Spring%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/","excerpt":"1.什么是SpringIOC控制反转​ 控制反转（Inversion of Cpntrol IoC），也被称为依赖注入，是面向对象编程的中的一种设计理念，用来降低程序代码之间的耦合 2.创建Spring项目","text":"1.什么是SpringIOC控制反转​ 控制反转（Inversion of Cpntrol IoC），也被称为依赖注入，是面向对象编程的中的一种设计理念，用来降低程序代码之间的耦合 2.创建Spring项目 在pom.xml中导入spring依赖 1234567891011121314151617181920 &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.6.RELEASE&lt;/spring.version&gt;&lt;/properties&gt; &lt;!--Spring相关依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 创建applicationContext.xml配置文件 123456789&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt; &lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt; &lt;&#x2F;beans&gt; 把对象创建交给spring管理 1&lt;bean id=\"accountService\" class=\"com.accp.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; 创建测试类 12345678//1.获取核心容器对象ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext(\"bean.xml\");//2.根据id获取bean对象AccountService as =ac.getBean(\"accountService\",AccountService.class);//3.根据对象调取方法as.saveAccount();//4.关闭核心容器对象ac.close(); 3.SpringAOP面向切面编程​ 面向切面编程是软件编程思想发展到一定阶段的掺入，是面向对象编程的有益补充。AOP一般适用于具有横切逻辑的场合，如访问控制、事务管理、性能监测等。 4.在applicationContext.xml中配置AOP切面 把通知Bean也交给spring来管理 使用aop:config标签表明开始配置AOP 使用aop:aspect标签表明配置切面 在aop:aspect内部使用对应标签来配置通知类型 12345678910111213141516171819202122&lt;!--配置Logger类--&gt;&lt;bean id=\"logger\" class=\"com.accp.utils.Logger\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!--配置切入点表达式 id表示指定表达式的唯一标识 expression属性用于指定表达式内容 此标签写在aop:aspect标签内部只能当前切面使用 它还可以写在aop:aspect外面，此时变为所有切面可以用。注意必须写在aop:aspect前面 --&gt; &lt;aop:pointcut id=\"proxy\" expression=\"execution(* com.accp.service.*.*(..))\"/&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置前置通知 在切入点方法之前执行--&gt; &lt;aop:before method=\"prLogger\" pointcut-ref=\"proxy\"&gt;&lt;/aop:before&gt; &lt;!--配置后置通知 在切入点方法正常执行之后执行--&gt; &lt;aop:after-returning method=\"afterReturnPrLogger\" pointcut-ref=\"proxy\"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知 在切入点方法产生异常之后执行--&gt; &lt;aop:after-throwing method=\"afterThrowingPrLogger\" pointcut-ref=\"proxy\"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置最终通知 无论切入点是否正常都会执行--&gt; &lt;aop:after method=\"afterPrLogger\" pointcut-ref=\"proxy\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; 5.配置AOP环绕通知12&lt;!--配置环绕通知--&gt;&lt;aop:around method=\"aroundLogger\" pointcut-ref=\"proxy\"&gt;&lt;/aop:around&gt; 123456789 if (\"\".equals(username) &amp;&amp; \"\".equals(pwd)) &#123; try &#123; pp.proceed(); &#125; catch (Throwable throwable) &#123; throw new RuntimeException(e); &#125;&#125; else &#123; System.out.println(\"用户名或密码错误\");&#125; ​ spring框架为我们提供一个接口：该接口中有一个方法proceed()此方法相当于明确调用切入点方法。该方法可以作环绕通知方法的参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用 6.bean标签的作用范围 singleton：单例的（默认值） prototype：多例的 request：用于web应用的请求范围 session：用于web应用的会话范围 global_session：作用于web应用的集群范围（全局会话范围），当不是集群范围的时候他就是session 7.bean对象的的生命周期 单例对象：出生：当容器创建时就一直活着 ​ 活着：只要容器还在就一直活着 ​ 死亡：容器销毁，对象死亡 ​ 总结：单例对象的生命周期和容器相同 多例对象：出生：当我们使用对象时spring框架为我们创建 ​ 活着：对象在使用过程中就就一直活着 ​ 死亡：当对象长时间不使用或者没有其他对象应用是，有java的垃圾回收机制回收","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://starbuck.top/tags/Spring/"}]},{"title":"Mybatis框架 — 动态SQL","slug":"Mybatis框架—动态SQL","date":"2019-12-13T16:00:00.000Z","updated":"2020-04-24T02:52:23.089Z","comments":true,"path":"2019/12/14/Mybatis框架—动态SQL/","link":"","permalink":"https://starbuck.top/2019/12/14/Mybatis%E6%A1%86%E6%9E%B6%E2%80%94%E5%8A%A8%E6%80%81SQL/","excerpt":"1.实现动态sql的元素 if：利用if实现简单的条件选择 choose(when，otherwise)：相当于java中的switch语句，通常与when和otherwise搭配 where：简化SQL语句中的where的条件判断 set：解决动态更新语句 trim：可以灵活的去除多余的关键字 foreach：迭代一个集合，通常用于in条件","text":"1.实现动态sql的元素 if：利用if实现简单的条件选择 choose(when，otherwise)：相当于java中的switch语句，通常与when和otherwise搭配 where：简化SQL语句中的where的条件判断 set：解决动态更新语句 trim：可以灵活的去除多余的关键字 foreach：迭代一个集合，通常用于in条件 2.使用if-where实现多条件查询1234567891011&lt;select id=\"findUserByUserName\" resultType=\"com.accp.pojo.user\"&gt; SELECT * FROM smbms_user u &lt;where&gt; &lt;if test=\"userRole!=null and userRole!=''\"&gt; AND u.`userRole`=#&#123;userRole&#125; &lt;/if&gt; &lt;if test=\"userName!=null and userName!=''\"&gt; AND u.`userName` LIKE CONCAT('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 3.使用if-trim实现多条件查询 prefix：前缀，作用是通过自动识别是否有返回值后，在trim包含的内容上加上前缀，如此处的where suffix：后缀：作用是在trim包含的内容上加上后缀 prefixOverrides：对于trim包含内容的首尾部进行指定的内容（如此处的 and ）的忽略 suffixOverrides：对于trim包含内容的首尾部进行指定内容的忽略 1234567891011&lt;select id=\"findUserByUserNameOrTrim\" resultType=\"com.accp.pojo.user\"&gt; SELECT * FROM smbms_user u &lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt; &lt;if test=\"userRole!=null and userRole!=''\"&gt; AND u.`userRole`=#&#123;userRole&#125; &lt;/if&gt; &lt;if test=\"userName!=null and userName!=''\"&gt; AND u.`userName` LIKE CONCAT('%',#&#123;userName&#125;,'%') &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 4.使用if+trim进行修改操作123456789101112&lt;update id=\"updateUser\" parameterType=\"com.accp.pojo.user\"&gt; UPDATE smbms_user &lt;trim prefix=\"set\" prefixOverrides=\",\"&gt; &lt;if test=\"userName!=null\"&gt; userName=#&#123;userName&#125;, &lt;/if&gt; &lt;if test=\"userPassword!=null\"&gt; userPassword=#&#123;userPassword&#125; &lt;/if&gt; &lt;/trim&gt; where id=#&#123;id&#125;&lt;/update&gt; 5.使用if+set实现更新操作123456789101112 &lt;update id=\"updateUser\" parameterType=\"com.accp.pojo.user\"&gt; UPDATE smbms_user &lt;set&gt; &lt;if test=\"userName!=null\"&gt; userName=#&#123;userName&#125; &lt;/if&gt; &lt;if test=\"userPassword!=null\"&gt; userPassword=#&#123;userPassword&#125;, &lt;/if&gt; where id=#&#123;id&#125; &lt;/set&gt;&lt;/update&gt; 6.使用foreach完成复杂查询 item：表示集合中每一个元素进行迭代的别名，如此处的 id index：指定一个名称，用于表示在迭代过程中，每次迭代的位置 open：表示该语句以什么开始，既然是in条件语句 所以此处从 “(“ 开始 close：表示该语句以什么结束，既然是in条件语句 所以此处从 “)” 结束 separator：表示在每次进行迭代的时候以什么符号进行分割，既然是in条件语句 所以此处以 “,” 进行分割 collection：要遍历的集合名称，数据类型有 List , Array , Map 三种类型，该参数为必选项； 123456&lt;select id=\"findUserByUserRole\" resultType=\"com.accp.pojo.user\"&gt; SELECT u.`id`,u.`userName`,u.`userCode` FROM smbms_user u WHERE userRole IN &lt;foreach collection=\"userRoles\" open=\"(\" separator=\",\" close=\")\" item=\"id\"&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; 1List&lt;user&gt; findUserByUserRole(@Param(\"userRoles\")List&lt;Integer&gt; userRoles); 7.使用choose(when 、otherwise)进行查询1234567891011&lt;select id=\"selectProviderByChoose\" resultType=\"com.accp.pojo.provider\"&gt; SELECT * FROM smbms_provider WHERE 1=1 &lt;choose&gt; &lt;when test=\"proCode!=null\"&gt;AND proCode LIKE CONCAT('%',#&#123;proCode&#125;,'%')&lt;/when&gt; &lt;when test=\"proName!=null\"&gt;AND proName LIKE CONCAT('%',#&#123;proName&#125;,'%')&lt;/when&gt; &lt;when test=\"proContact!=null\"&gt;AND proContact LIKE CONCAT('%',#&#123;proContact&#125;,'%')&lt;/when&gt; &lt;otherwise&gt; AND YEAR(creationDate)=YEAR(#&#123;creationDate&#125;) &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; when：当其test条件满足时，就会输出when元素中的内容，一旦有when条件满足是就会跳出choose otherwise：当所有when条件都不满足时候，就会输出otherwise元素中的内容 8.使用if+trim进行动态添加操作12345678910111213&lt;insert id=\"insertBill\"&gt; INSERT INTO smbms_bill &lt;trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\" prefixOverrides=\",\"&gt; &lt;if test=\"billCode!=null and billCode!=''\"&gt;billCode,&lt;/if&gt; &lt;if test=\"productName!=null and productName!=''\"&gt;productName,&lt;/if&gt; &lt;if test=\"productDesc!=null and productDesc!=''\"&gt;productDesc&lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=\"VALUES(\" suffix=\")\" suffixOverrides=\",\" prefixOverrides=\",\"&gt; &lt;if test=\"billCode!=null and billCode!=''\"&gt;#&#123;billCode&#125;,&lt;/if&gt; &lt;if test=\"productName!=null and productName!=''\"&gt;#&#123;productName&#125;,&lt;/if&gt; &lt;if test=\"productDesc!=null and productDesc!=''\"&gt;#&#123;productDesc&#125;&lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; 9.使用PageHelper分页查询 在pom.xml中导入坐标 1234567891011&lt;!--分页依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; 在mybatis主配置文件mybatis-config.xml中配置分页插件 1234 &lt;!--配置分页插件--&gt;&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageHelper\"&gt;&lt;/plugin&gt;&lt;/plugins&gt; 在mapper.xml文件中写SQL语句 1234&lt;select id=\"selectProviderByPageHelper\" resultType=\"com.accp.pojo.provider\"&gt; SELECT id,proName,proCode,creationDate FROM smbms_provider ORDER BY creationDate DESC&lt;/select&gt; 写测试类 123456789101112@Testpublic void selectProviderByPageHelper()&#123; userMapper mapper = sqlSession.getMapper(userMapper.class); /* 第一个参数从第几页开始，第二个参数每页显示多少条*/ PageHelper.startPage(2,5); List&lt;provider&gt; providerList = mapper.selectProviderByPageHelper(); PageInfo&lt;provider&gt; pageInfo = new PageInfo&lt;&gt;(providerList); List&lt;provider&gt; list = pageInfo.getList(); for (Product provider : list) &#123; System.out.println(provider); &#125;&#125;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://starbuck.top/tags/Mybatis/"}]},{"title":"Mybatis框架 — SQL映射文件","slug":"Mybatis框架—SQL映射文件","date":"2019-12-12T16:00:00.000Z","updated":"2020-04-24T02:52:27.794Z","comments":true,"path":"2019/12/13/Mybatis框架—SQL映射文件/","link":"","permalink":"https://starbuck.top/2019/12/13/Mybatis%E6%A1%86%E6%9E%B6%E2%80%94SQL%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6/","excerpt":"1.SQL映射文件的几个顶级元素配置 mapper：映射文件的根元素节点，只有一个namespace属性，其作用是用于区分不同的mapper；绑定DAO接口，即面向接口编程，当namespace绑定某一接口后，可以不用写该接口的实现类，mybatis会通过接口的完整限定类名查找到对应的mapper配置来执行SQL语句。因此namespace的命名必须要跟接口同名 cache：配置给定命名空间的缓存 acahe-ref：从其他命名空间引用缓存配置 resultMap：用来描述数据库结果集和对象的对应关系 sql：可重用的SQL块，也可以被其他语句引用","text":"1.SQL映射文件的几个顶级元素配置 mapper：映射文件的根元素节点，只有一个namespace属性，其作用是用于区分不同的mapper；绑定DAO接口，即面向接口编程，当namespace绑定某一接口后，可以不用写该接口的实现类，mybatis会通过接口的完整限定类名查找到对应的mapper配置来执行SQL语句。因此namespace的命名必须要跟接口同名 cache：配置给定命名空间的缓存 acahe-ref：从其他命名空间引用缓存配置 resultMap：用来描述数据库结果集和对象的对应关系 sql：可重用的SQL块，也可以被其他语句引用 insert：映射插入语句 1234&lt;insert id&#x3D;&quot;insertProvider&quot; parameterType&#x3D;&quot;com.accp.pojo.provider&quot;&gt; INSERT INTO &#96;smbms_provider&#96; (proCode,proName,proDesc) VALUES (#&#123;proCode&#125;, #&#123;proName&#125;,#&#123;proDesc&#125;)&lt;&#x2F;insert&gt; update：映射更新语句 123&lt;update id&#x3D;&quot;updateProvider&quot; parameterType&#x3D;&quot;com.accp.pojo.provider&quot;&gt; UPDATE &#96;smbms_provider&#96; SET modifyDate&#x3D;#&#123;modifyDate&#125;,modifyBy&#x3D;#&#123;modifyBy&#125; WHERE id&#x3D;#&#123;id&#125;&lt;&#x2F;update&gt; delete：映射删除语句 123&lt;delete id&#x3D;&quot;deleteById&quot; parameterType&#x3D;&quot;com.accp.pojo.provider&quot;&gt; DELETE FROM &#96;smbms_provider&#96; WHERE id&#x3D;#&#123;id&#125;&lt;&#x2F;delete&gt; select：映射查询语句 12345678&lt;select id&#x3D;&quot;selectBill&quot; resultType&#x3D;&quot;com.accp.pojo.bill&quot;&gt; SELECT b.*,p.* FROM smbms_bill b, smbms_provider p WHERE b.providerId&#x3D;p.&#96;id&#96; AND b.providerId&#x3D;#&#123;providerId&#125; AND b.&#96;isPayment&#96;&#x3D;#&#123;isPayment&#125; AND b.productName like CONCAT (&#39;%&#39;,#&#123;productName&#125;,&#39;%&#39;)&lt;&#x2F;select&gt; 2.resultType和resultMap的关联和区别 resultType表示返回类型，包括是基础数据类型和复杂数据类型 resultMap则是对应外部resultMap定义的引用，对应外部resultMap的id，表示返回结果映射到哪一个resultMap上 resultType和resultMap的关联： 在mybatis进行查询映射时候，其实查询出来的每个字段值都放在一个对应的Map中，其中键名是字段名，值则是其对应的值。当select元素提供返回类型属性是resultType的时候，mybatis会将Map里面的键值对取出赋给resultType所指定对象的对应属性（既调用对象里属性的set方法进行填充）。 当我们提供的返回类型是resultMap时候，因为Map不能很好的表示领域模型，所以就需要通过进一步的定义把它转化为对应的实体对象。 resultType和resultMap本质上是一样的，都是Map数据结构，但是这两者只能二选一 resultMap的自动映射级别： NONE：禁止自动匹配 PARTIAL：（默认）自动匹配所有属性，有内部嵌套（association、collection）的除外 FULL：自动匹配所有 123&lt;settings&gt; &lt;setting name=\"autoMappingBehavior\" value=\"NONE\"/&gt;&lt;/settings&gt; 3.使用@Param注解实现多参数入参1int deleteById(@Param(\"id\") int id); 123&lt;delete id&#x3D;&quot;deleteById&quot; parameterType&#x3D;&quot;com.accp.pojo.provider&quot;&gt; DELETE FROM &#96;smbms_provider&#96; WHERE id&#x3D;#&#123;id&#125;&lt;&#x2F;delete&gt; 4.使用resultMap实现高级结果映射 resultMap基本配置项 1.1.resultMap属性 id：resultMap的唯一标识 type：表示该resultMap的映射结果类型（通常是java实体类） 1.2.resultMap子节点属性 id：一般对应数据库中该行的主键id，设置此项可以提升mybatis性能 result：映射到JavaBean的某个“简单类型”属性，如基础类型、包装类 123456&lt;resultMap type&#x3D;&quot;com.accp.pojo.user&quot; id&#x3D;&quot;userMap&quot;&gt; &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt; &lt;result property&#x3D;&quot;userCode&quot; column&#x3D;&quot;userCode&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userName&quot; column&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userPassword&quot; column&#x3D;&quot;userPassword&quot;&#x2F;&gt;&lt;&#x2F;resultMap&gt; association 2.1.association属性 JavaType：完整地java类名或别名，若映射到JavaBean，则mybatis通常会自动检测到其类型；若映射到一个HashMap，则应明确指定JavaType，来确保所需行为。此处为com.accp.pojo.role property：映射数据库列的实体对象的属性，此处为在user里面定义的role属性 2.2.association子节点属性 id result property：映射数据库列的实体对象的属性。此处为role属性 column：数据库列名或别名 1234567891011 &lt;resultMap type&#x3D;&quot;com.accp.pojo.user&quot; id&#x3D;&quot;userMap&quot;&gt; &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt; &lt;result property&#x3D;&quot;userCode&quot; column&#x3D;&quot;userCode&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userName&quot; column&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userPassword&quot; column&#x3D;&quot;userPassword&quot;&#x2F;&gt; &lt;association property&#x3D;&quot;role&quot; javaType&#x3D;&quot;com.accp.pojo.role&quot;&gt; &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt; &lt;result property&#x3D;&quot;roleCode&quot; column&#x3D;&quot;roleCode&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;roleName&quot; column&#x3D;&quot;roleName&quot;&#x2F;&gt; &lt;&#x2F;association&gt;&lt;&#x2F;resultMap&gt; collection ofType：完整的java类名或别名，即集合所包含的类型。此处为Address property：映射数据库列的实体对象的属性。此处为在User里定义的属性：addressList 1private List&lt;Address&gt; addressList; 1234567891011&lt;resultMap type&#x3D;&quot;com.accp.pojo.user&quot; id&#x3D;&quot;userMap&quot;&gt; &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt; &lt;result property&#x3D;&quot;userCode&quot; column&#x3D;&quot;userCode&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userName&quot; column&#x3D;&quot;userName&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;userPassword&quot; column&#x3D;&quot;userPassword&quot;&#x2F;&gt; &lt;collection property&#x3D;&quot;addressList&quot; ofType&#x3D;&quot;address&quot;&gt; &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;id&quot;&gt;&lt;&#x2F;id&gt; &lt;result property&#x3D;&quot;tel&quot; column&#x3D;&quot;tel&quot;&#x2F;&gt; &lt;result property&#x3D;&quot;postCode&quot; column&#x3D;&quot;postCode&quot;&#x2F;&gt; &lt;&#x2F;collection&gt; &lt;&#x2F;resultMap&gt; 5.mybatis缓存 一级缓存：是基于mybatis自带的HashMap本地缓存，作用范围为session域内，当session调用flish()或close()方法后，该session中的所有缓存就会被清空 二级缓存：超出session范围之外，可以被所有sqlsession共享 二级缓存配置 （1）在mybatis-config.xml中设置 123&lt;settings&gt; &lt;setting name&#x3D;&quot;cacheEnabled&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;&lt;&#x2F;settings&gt; （2）在mapper.xml中设置缓存 1&lt;cache eviction&#x3D;&quot;FIFO&quot; flushInterval&#x3D;&quot;60000&quot; size&#x3D;&quot;512&quot; readOnly&#x3D;&quot;true&quot;&gt;&lt;&#x2F;cache&gt; （3）在mapper文件配置支持cache后，如需对个别查询进行调整，可单独设置cache 123&lt;select id&#x3D;&quot;selectBill&quot; resultType&#x3D;&quot;com.accp.pojo.bill&quot; useCache&#x3D;&quot;true&quot;&gt; ......&lt;&#x2F;select&gt;","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://starbuck.top/tags/Mybatis/"}]},{"title":"Mybatis框架 — 初始Mybatis","slug":"Mybatis框架—初始Mybatis","date":"2019-12-11T16:00:00.000Z","updated":"2020-04-24T02:52:16.853Z","comments":true,"path":"2019/12/12/Mybatis框架—初始Mybatis/","link":"","permalink":"https://starbuck.top/2019/12/12/Mybatis%E6%A1%86%E6%9E%B6%E2%80%94%E5%88%9D%E5%A7%8BMybatis/","excerpt":"1.Mybatis框架及ORM1.1. Mybatis框架简介​ Mybatis是一个开源的数据持久层框架，它的内部封装了通过了JDBC访问数据库的操作，支持普通的SQL查 询、储存过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。其主要思想是将SQL 语句剥离出来，配置在配置文件中，实现SQL的灵活配置","text":"1.Mybatis框架及ORM1.1. Mybatis框架简介​ Mybatis是一个开源的数据持久层框架，它的内部封装了通过了JDBC访问数据库的操作，支持普通的SQL查 询、储存过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。其主要思想是将SQL 语句剥离出来，配置在配置文件中，实现SQL的灵活配置 1.2.什么是ORM​ ORM(Object / Relational Mapping)即对象/关系映射，是一种持久化技术，他在对象模型和关系型数据库之间建 立关系，并且提供一种机制，通过JavaBean对象去操作数据库表中的数据。 2.Mybatis环境搭建 创建maven项目，在pom.xml文件中导入Mybatis的坐标 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; 编写Mybatis核心配置文件 mybatis-config.xml（文件节点有一定顺序，不按照顺序排位会报错） 1234567891011121314151617181920212223242526272829&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入jdbc.properties文件--&gt; &lt;properties resource&#x3D;&quot;jdbc.properties&quot;&gt;&lt;&#x2F;properties&gt; &lt;!--给全限定类名配置别名--&gt; &lt;typeAliases&gt; &lt;typeAlias type&#x3D;&quot;com.accp.pojo.user&quot; alias&#x3D;&quot;user&quot;&gt;&lt;&#x2F;typeAlias&gt; &lt;&#x2F;typeAliases&gt; &lt;!--配置Mybatis多套运行环境--&gt; &lt;environments default&#x3D;&quot;mysql&quot;&gt; &lt;environment id&#x3D;&quot;mysql&quot;&gt; &lt;!--配置事务管理，采用JDBC的事务管理--&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;&lt;&#x2F;transactionManager&gt; &lt;!--POOLED：mybatis自带的数据源 JNDI：基于tomcat的数据源--&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;password&#125;&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;!--将mapper文件到配置文件中--&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;com&#x2F;accp&#x2F;dao&#x2F;userMapper.xml&quot;&gt;&lt;&#x2F;mapper&gt; &lt;!--&lt;package name&#x3D;&quot;com&#x2F;accp&quot;&#x2F;&gt;--&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; mybatis-config.xml文件的几个常用元素作用如下： configuration：配置文件的根节点元素 properties：通过resource属性从外部指定properties文件，该属性文件描述数据库连接的相关配置 settings：设置mybatis运行中的一些行为，例如使用log4j实现日志功能 environments：表示配置mybatis多套运行环境，将SQL映射到不同的数据库上，该元素节点下可以配置多个environment子元素节点，但必须通过default指定一个默认运行环境 environment：配置mybatis的一套运行环境，需要指定运行环境ID、事务管理、数据源配置等相关信息 mappers：作用是告诉mybatis去哪里找SQL映射文件 mapper：mappers的子元素节点，具体指SQL映射文件的路径，其中resource属性表示SQL映射文件的 创建实体类 创建dao接口 创建SQL映射文件mapper.xml 1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace&#x3D;&quot;com.accp.dao.userMapper&quot;&gt; &lt;sql id&#x3D;&quot;getPro&quot;&gt; select u.id ,u.userName,u.userPassword &lt;&#x2F;sql&gt; &lt;select id&#x3D;&quot;getUserByUser&quot; resultType&#x3D;&quot;user&quot; parameterType&#x3D;&quot;user&quot;&gt; &lt;include refid&#x3D;&quot;getPro&quot;&#x2F;&gt;FROM smbms_user u where u.&#96;userName&#96; LIKE CONCAT(&#39;%&#39;,#&#123;userName&#125;,&#39;%&#39;) and userPassword&#x3D;#&#123;userPassword&#125; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; mapper.xml定义了SQL语句，其中各元素含义如下 mapper：映射文件的根元素节点，只有一个属性namespace用于区分不同的mapper，全局唯一 sql：用于提取多余的SQL语句片段。 只要调用标签就可以了，refid属性值填标签的id属性值 select：表示查询语句。 id属性表示该命名空间下唯一标识符， resultType属性表示SQL语句返回值类型 parameterType表示传入的参数类型：基本数据类型：int,string,long,Date; 复杂数据类型：类和Map 编写测试类 1234567891011121314151617181920212223try &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"mybatis-config.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession sqlSession = factory.openSession(); //4.使用SqlSession创建Dao接口对象 userMapper mapper = sqlSession.getMapper(userMapper.class); //5.使用代理对象执行方法 List&lt;user&gt; users = mapper.getUsers(); for (user user : users) &#123; System.out.println(user); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.关闭sqlSession对象 if (null!=sqlSession)&#123; sqlSession.close(); &#125; &#125; 3.Mybatis的基本要素——核心思想3.1：SqlSessionFactoryBuilder SqlSessionFactoryBuilder的作用：负责构建SqlSessionFactory（通过读取xml文件和编程构造方式），并且提供多个build()方法的重载 SqlSessionFactoryBuilder的生命周期和作用域：SqlSessionFactoryBuilder最大特点是：用过即丢。一旦创建SqlSessionFactory对象后，这个类就不需要存在了，因此SqlSessionFactoryBuilder的最佳范围就是存在于方法体，也就是局部变量 3.2：SqlSessionFactory SqlSessionFactory的作用：创建SqlSession示例的工厂，通过SqlSessionFactory提供的openSession()方法来获取SqlSession实例。openSession(）方法的参数为Boolean值时，若传入true时表示关闭事务管理，自动提交；否则相反。若不传入参数则默认参数为true SqlSessionFactory的生命周期和作用域：SqlSessionFactory对象一旦创建，就会在整个应用运行过程中始终存在，没有理由去销毁或在创建它，并且在应用运行过程中也不建议多次创建SqlSessionFactory。因此SqlSessionFactory最佳作用域是Application 3.3：SqlSession SqlSession的作用：用于持久化操作的对象，类似于JDBC中的Connection。它提供了面向数据库执行SQL命令所需要的方法，可以通过SqlSession实例直接运行到以映射的SQL语句 SqlSession的作用域和生命周期：SqlSession对应着一次数据库会话。由于数据库会话不是永久的，因此SqlSession的生命周期也不应该是永久的。相反，在每次访问数据库时都需要创建它，创建SqlSession的地方只有一个，那就是SqlSessionFactory提供的openSession()方法。每个线程都有自己的SqlSession实例，且不能被共享，也不是线程安全的。因此最佳的作用域范围是request作用域或者方法体作用域内。关闭SqlSession非常重要","categories":[{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://starbuck.top/tags/Mybatis/"}]}],"categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://starbuck.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"SrpingCloud","slug":"SrpingCloud","permalink":"https://starbuck.top/categories/SrpingCloud/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/categories/SpringBoot/"},{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/categories/SSM/"}],"tags":[{"name":"适配器模式","slug":"适配器模式","permalink":"https://starbuck.top/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"name":"桥接模式","slug":"桥接模式","permalink":"https://starbuck.top/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"name":"代理模式","slug":"代理模式","permalink":"https://starbuck.top/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","permalink":"https://starbuck.top/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","permalink":"https://starbuck.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"微服务","slug":"微服务","permalink":"https://starbuck.top/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"Swagger2","slug":"Swagger2","permalink":"https://starbuck.top/tags/Swagger2/"},{"name":"TK_MyBatis","slug":"TK-MyBatis","permalink":"https://starbuck.top/tags/TK-MyBatis/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://starbuck.top/tags/SpringBoot/"},{"name":"SSM","slug":"SSM","permalink":"https://starbuck.top/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://starbuck.top/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"https://starbuck.top/tags/Spring/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://starbuck.top/tags/Mybatis/"}]}